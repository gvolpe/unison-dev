-- ########### using abilities part 1 ############ --

abilities.stopIfTrue : (a ->{g} Boolean) -> a ->{g, Abort} a
abilities.stopIfTrue predicate a =
  if predicate a then Abort.abort else a

abilities.stopIfTrueStore : (a -> Boolean) -> a -> {Abort, Store a} a
abilities.stopIfTrueStore predicate a =
  Store.put a
  abilities.stopIfTrue predicate a

abilities.nonEmptyName : Text -> Text
abilities.nonEmptyName name =
  maybeName : Optional Text
  maybeName = 
    toOptional! do
      abilities.stopIfTrue (text -> text === "") name
  Optional.getOrElse "???" maybeName

-- > nonEmptyName ""

tryEmit1 : '{Stream Text}()
tryEmit1 = do Stream.emit "Hello World"

tryEmit2 : '{Stream Text}()
tryEmit2 _ =
  Stream.emit "Hello World"

tryEmit3 : '{Stream Text}()
tryEmit3 = '(Stream.emit "Hello World")

-- ########### error handling with abilities ############ --

abilities.divBy : Nat -> Nat ->{Abort} Nat
abilities.divBy a b = match b with
  0 -> Abort.abort
  n -> a Nat./ n

-- > toDefault! '(1) '(divBy 3 1)
-- > toEither do Abort.toThrow "boom" '(divBy 3 0)

-- > Some 5 |> Optional.toAbort

abilities.divByThrow : Nat -> Nat ->{Throw Text} Nat
abilities.divByThrow a b = match b with
  0 -> throw "Cannot divide by zero"
  n -> a Nat./ n

-- > toEither do divByThrow 3 1

abilities.divByException : Nat -> Nat ->{Exception} Nat
abilities.divByException a b = match b with
  0 -> Exception.raise (Generic.failure "Cannot divide by zero" b)
  n -> a Nat./ n

-- > catch do divByException 3 0
-- > unsafeRun! do divByException 3 0

-- ########### writing your own abilities ############ --

ability KVStore a b where
  abilities.KVStore.get :
    a ->{KVStore a b} Optional b
  abilities.KVStore.put :
    a -> b ->{KVStore a b} ()

abilities.program : '{KVStore Nat Nat} Text
abilities.program = do
  KVStore.put 3 4
  KVStore.put 5 6
  maybeFour = KVStore.get 4
  Optional.map Nat.toText maybeFour
    |> Optional.getOrElse "nothing here"

abilities.inMemory : '{g, KVStore a b} r -> {g} (r, Map a b)
abilities.inMemory request =
  impl : Map a b -> Request {KVStore a b} r -> (r, Map a b)
  impl kv = cases
    { pure } -> (pure, kv)
    { KVStore.get key -> resume } ->
      handle resume (Map.get key kv) with impl kv
    { KVStore.put key value -> resume } ->
      updatedKv = Map.insert key value kv
      handle !resume with impl updatedKv
  handle !request with impl Map.empty

-- > inMemory program

-- ########### abilities for the monadically inclined ############ --

failure.safeDiv1 : Nat -> Nat ->{Exception} Nat
failure.safeDiv1 a b =
  use Nat / ==
  if b == 0 then Exception.raise (Generic.failure "Oops. Zero" b)
  else a / b

-- > catch do failure.safeDiv1 3 1

failure.safeDiv2 : '{IO, Exception} Nat
failure.safeDiv2 _ =
  use Nat / ==
  a = randomNat()
  b = randomNat()
  if b == 0 then Exception.raise (Generic.failure "Oops. Zero" b)
  else a / b

failure.safeDiv3 : '{IO, Exception, Store Text} Nat
failure.safeDiv3 =
  do
    use Nat / == toText
    use Text ++
    a = randomNat()
    b = randomNat()
    Store.put (toText a ++ "/" ++ toText b)
    if b == 0 then Exception.raise (Generic.failure "Oops. Zero" b)
    else a / b

failure.forMonadicallyInclined.final : '{IO, Exception} ()
failure.forMonadicallyInclined.final = do
  withInitialValue "empty" do
    use Text ++
    result = failure.safeDiv3()
    printLine (Store.get ++ "=" ++ Nat.toText result)
